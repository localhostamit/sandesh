# Creating chat.html file for the user so they can download and push to their repo.
html_content = r'''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Modern P2P Chat - Video & Photo Sharing</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
      /* (unchanged styles - copied from your file) */
      *{margin:0;padding:0;box-sizing:border-box}
      body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto, Oxygen, Ubuntu, Cantarell,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);min-height:100vh;padding:20px;display:flex;justify-content:center;align-items:center}
      .container{background:white;border-radius:20px;box-shadow:0 20px 60px rgba(0,0,0,0.3);max-width:900px;width:100%;overflow:hidden}
      .header{background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;padding:25px 30px;text-align:center}
      .header h1{font-size:28px;font-weight:600;margin-bottom:8px}
      .header p{font-size:14px;opacity:.9}
      .content{padding:30px}
      .card{background:#f8f9fa;border-radius:12px;padding:20px;margin-bottom:20px;border:1px solid #e9ecef}
      .card-title{font-size:16px;font-weight:600;color:#495057;margin-bottom:12px;display:flex;align-items:center;gap:8px}
      .id-display{background:white;padding:12px 16px;border-radius:8px;border:2px dashed #667eea;font-family:'Courier New',monospace;font-weight:bold;color:#667eea;word-break:break-all;margin:10px 0}
      .input-group{display:flex;gap:10px;margin-top:12px}
      input[type="text"], input[type="password"]{flex:1;padding:12px 16px;border:2px solid #e9ecef;border-radius:8px;font-size:14px;transition:border-color .3s}
      input[type="text"]:focus, input[type="password"]:focus{outline:none;border-color:#667eea}
      button{padding:12px 24px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;border:none;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;transition:transform .2s,box-shadow .2s}
      button:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(102,126,234,.4)}
      button:active{transform:translateY(0)}
      button:disabled{opacity:.5;cursor:not-allowed;transform:none}
      .btn-secondary{background:#6c757d}
      .btn-danger{background:#dc3545}
      .btn-success{background:#28a745}
      .status{display:inline-block;padding:8px 16px;border-radius:20px;font-size:13px;font-weight:600;margin-top:10px}
      .status.waiting{background:#fff3cd;color:#856404}
      .status.connected{background:#d4edda;color:#155724}
      .status.error{background:#f8d7da;color:#721c24}
      #chat-box{display:none}
      #messages{height:400px;overflow-y:auto;padding:20px;background:#f8f9fa;border-radius:12px;margin-bottom:15px;display:flex;flex-direction:column;gap:12px}
      .message{max-width:70%;padding:12px 16px;border-radius:12px;word-wrap:break-word;animation:messageSlide .3s ease}
      @keyframes messageSlide{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
      .my-msg{align-self:flex-end;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:white;border-bottom-right-radius:4px}
      .peer-msg{align-self:flex-start;background:white;color:#495057;border:1px solid #e9ecef;border-bottom-left-radius:4px}
      .message-img{max-width:100%;border-radius:8px;margin-top:8px;cursor:pointer}
      .message-controls{display:flex;gap:10px;margin-bottom:15px}
      .message-controls button{flex:1;display:flex;align-items:center;justify-content:center;gap:8px}
      #photo-input{display:none}
      .video-container{margin-bottom:20px;background:#000;border-radius:12px;overflow:hidden;position:relative}
      .video-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;padding:10px}
      video{width:100%;height:auto;background:#000;border-radius:8px}
      .video-controls{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:10px;background:rgba(0,0,0,.7);padding:10px;border-radius:25px}
      .video-controls button{width:45px;height:45px;border-radius:50%;padding:0;display:flex;align-items:center;justify-content:center}
      .hidden{display:none!important}
      @media (max-width:768px){.container{border-radius:0}.video-grid{grid-template-columns:1fr}#messages{height:300px}.message{max-width:85%}}
    </style>
</head>
<body>

  <div class="container">
    <div class="header">
      <h1>ðŸš€ Modern P2P Chat</h1>
      <p>Secure peer-to-peer messaging, video calls, and photo sharing</p>
    </div>

    <div class="content">
      <div class="card">
        <div class="card-title">ðŸ“‹ Your ID</div>
        <div id="my-id" class="id-display">Generating...</div>
        <small style="color:#6c757d">Share this ID or generate a connect code (safer) below</small>

        <!-- NEW: Connect code UI -->
        <div style="margin-top:12px;display:flex;gap:10px;flex-wrap:wrap">
          <input id="passphrase-generate" type="password" placeholder="Passphrase to protect code (required)" style="flex:2" />
          <button id="gen-code-btn" onclick="generateConnectCode()" title="Encrypt & produce small code">Generate Connect Code</button>
          <button id="copy-code-btn" onclick="copyConnectCode()" class="btn-secondary">Copy Code</button>
        </div>

        <div id="connect-code" class="id-display" style="margin-top:12px;word-break:break-all;display:none"></div>
      </div>

      <div class="card">
        <div class="card-title">ðŸ”— Connect to Friend</div>

        <!-- Connect via ID (existing) -->
        <div class="input-group" style="margin-bottom:10px;">
          <input type="text" id="friend-id" placeholder="Paste friend's full ID here (or use code below)">
          <button onclick="connectToPeer()">Connect</button>
        </div>

        <!-- NEW: Connect via code -->
        <div style="margin-top:8px;">
          <input id="connect-code-input" type="text" placeholder="Paste friend's connect code here" />
          <input id="passphrase-connect" type="password" placeholder="Passphrase to decrypt code (required)" style="margin-top:8px" />
          <div class="input-group" style="margin-top:8px">
            <button onclick="connectUsingCode()">Connect using code</button>
            <button onclick="clearConnectCodeInputs()" class="btn-secondary">Clear</button>
          </div>
        </div>

        <div class="status waiting" id="status">Ready to connect</div>
      </div>

      <div id="chat-box">
        <div id="video-section" class="hidden">
          <div class="video-container">
            <div class="video-grid">
              <video id="local-video" autoplay muted playsinline></video>
              <video id="remote-video" autoplay playsinline></video>
            </div>
            <div class="video-controls">
              <button id="mute-btn" class="btn-secondary" onclick="toggleMute()">ðŸŽ¤</button>
              <button id="video-btn" class="btn-secondary" onclick="toggleVideo()">ðŸ“¹</button>
              <button class="btn-danger" onclick="endCall()">ðŸ“ž</button>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="message-controls">
            <button id="call-btn" onclick="startCall()">ðŸ“¹ Video Call</button>
            <button onclick="document.getElementById('photo-input').click()">ðŸ“· Send Photo</button>
          </div>
          <input type="file" id="photo-input" accept="image/*" onchange="sendPhoto()" />
          <div id="messages"></div>
          <div class="input-group">
            <input type="text" id="msg-input" placeholder="Type a message..." onkeypress="handleEnter(event)" />
            <button onclick="sendMessage()">Send</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
  Summary of new behaviour:
  - generateConnectCode(): encrypts your full peer.id with AES-GCM (key derived from passphrase).
      produces a compact base64url string shown in UI.
  - connectUsingCode(): takes code + passphrase, decrypts to obtain peer id, connects.
  - After peer connection, an auth handshake ensures both peers know passphrase.
  - Uses Web Crypto (PBKDF2 + AES-GCM). Make sure users pick decent passphrases.
*/

/////////////////////// Crypto helpers (Web Crypto) ///////////////////////

function toBase64Url(bytes) {
  const b64 = btoa(String.fromCharCode(...new Uint8Array(bytes)));
  return b64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
function fromBase64Url(s) {
  s = s.replace(/-/g, '+').replace(/_/g, '/');
  while (s.length % 4) s += '=';
  const str = atob(s);
  const bytes = new Uint8Array(str.length);
  for (let i=0;i<str.length;i++) bytes[i]=str.charCodeAt(i);
  return bytes;
}

async function deriveKey(passphrase, salt, iterations = 120000) {
  const enc = new TextEncoder();
  const passkey = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: enc.encode(salt),
      iterations: iterations,
      hash: 'SHA-256'
    },
    passkey,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt','decrypt']
  );
}

async function encryptWithPassphrase(plaintext, passphrase) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const salt = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(passphrase, Array.from(salt).join('-'));
  const enc = new TextEncoder();
  const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, enc.encode(plaintext));
  const combined = new Uint8Array(salt.byteLength + iv.byteLength + ciphertext.byteLength);
  combined.set(salt, 0);
  combined.set(iv, salt.byteLength);
  combined.set(new Uint8Array(ciphertext), salt.byteLength + iv.byteLength);
  return toBase64Url(combined);
}

async function decryptWithPassphrase(code, passphrase) {
  const combined = fromBase64Url(code);
  if (combined.length < 12+12) throw new Error('code too short');
  const salt = combined.slice(0,12);
  const iv = combined.slice(12,24);
  const ciphertext = combined.slice(24);
  const key = await deriveKey(passphrase, Array.from(salt).join('-'));
  const plainbuf = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);
  const dec = new TextDecoder();
  return dec.decode(plainbuf);
}

////////////////////////////////////////////////////////////////////////////

let peer = null;
let conn = null;
let call = null;
let localStream = null;
let isAudioMuted = false;
let isVideoOff = false;

let myIdDisplay = document.getElementById('my-id');
let statusDisplay = document.getElementById('status');
let chatBox = document.getElementById('chat-box');
let msgDisplay = document.getElementById('messages');
let videoSection = document.getElementById('video-section');
let localVideo = document.getElementById('local-video');
let remoteVideo = document.getElementById('remote-video');

let AUTH_KEY = null;
let LOCAL_AUTH_TOKEN = null;

function createPeer() {
  peer = new Peer();
  peer.on('open', function(id) {
    myIdDisplay.innerText = id;
    updateStatus('Ready to connect', 'waiting');
  });

  peer.on('connection', function(connection) {
    setupConnection(connection);
  });

  peer.on('call', function(incomingCall) {
    if (confirm('Incoming video call. Accept?')) {
      navigator.mediaDevices.getUserMedia({ video: true, audio: true })
        .then(stream => {
          localStream = stream;
          localVideo.srcObject = stream;
          incomingCall.answer(stream);
          call = incomingCall;
          incomingCall.on('stream', remoteStream => {
            remoteVideo.srcObject = remoteStream;
            showVideoSection();
          });
          incomingCall.on('close', () => {
            endCall();
          });
        })
        .catch(err => {
          console.error('Failed to get media:', err);
          alert('Camera/microphone access denied');
        });
    }
  });
}

createPeer();

function connectToPeer() {
  let friendId = document.getElementById('friend-id').value.trim();
  if (!friendId) return alert("Enter an ID!");
  updateStatus('Connecting...', 'waiting');

  const connection = peer.connect(friendId);
  connection.on('open', function() {
    setupConnection(connection);
  });
  connection.on('error', function(err) {
    updateStatus('Connection failed', 'error');
    console.error('Connection error:', err);
  });
}

async function generateConnectCode() {
  const passphrase = document.getElementById('passphrase-generate').value;
  if (!passphrase) return alert('Enter a passphrase to protect the connect code (share it out-of-band).');

  if (!peer || !peer.id) return alert('Peer ID not ready yet. Wait a moment.');

  try {
    const code = await encryptWithPassphrase(peer.id, passphrase);
    const el = document.getElementById('connect-code');
    el.textContent = code;
    el.style.display = 'block';
    localStorage.setItem('last_connect_code', code);
    updateStatus('Connect code generated (copy & share).', 'waiting');
  } catch (e) {
    console.error(e);
    alert('Failed to generate connect code: ' + e.message);
  }
}

function copyConnectCode() {
  const el = document.getElementById('connect-code');
  if (el && el.textContent) {
    navigator.clipboard?.writeText(el.textContent).then(()=> {
      alert('Connect code copied');
    }, ()=> {
      alert('Copy failed â€” select and copy manually.');
    });
  } else {
    alert('No connect code to copy. Generate one first.');
  }
}

function clearConnectCodeInputs() {
  document.getElementById('connect-code-input').value = '';
  document.getElementById('passphrase-connect').value = '';
}

async function connectUsingCode() {
  const code = document.getElementById('connect-code-input').value.trim();
  const passphrase = document.getElementById('passphrase-connect').value;
  if (!code) return alert('Paste the connect code you received.');
  if (!passphrase) return alert('Enter the passphrase that protects the connect code.');

  try {
    updateStatus('Decrypting code...', 'waiting');
    const peerId = await decryptWithPassphrase(code, passphrase);
    if (!peerId || typeof peerId !== 'string' || peerId.length < 3) {
      throw new Error('Invalid peer id decrypted');
    }
    await deriveAuthKey(passphrase);
    updateStatus('Connecting to decrypted ID...', 'waiting');
    const connection = peer.connect(peerId, { reliable: true });
    connection.on('open', function() {
      setupConnection(connection);
    });
    connection.on('error', function(err) {
      updateStatus('Connection failed', 'error');
      console.error('Connection error:', err);
    });
  } catch (e) {
    console.error(e);
    alert('Failed to decrypt/connect using code: ' + e.message);
    updateStatus('Ready to connect', 'waiting');
  }
}

async function deriveAuthKey(passphrase) {
  const enc = new TextEncoder();
  const salt = 'p2p-auth-salt@' + location.hostname;
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'PBKDF2', false, ['deriveBits','deriveKey']);
  const derivedBits = await crypto.subtle.deriveBits({ name: 'PBKDF2', salt: enc.encode(salt), iterations: 120000, hash: 'SHA-256' }, baseKey, 256);
  AUTH_KEY = derivedBits;
  const tokenBytes = crypto.getRandomValues(new Uint8Array(12));
  LOCAL_AUTH_TOKEN = toBase64Url(tokenBytes);
}

async function computeHMAC(message) {
  if (!AUTH_KEY) throw new Error('Auth key not derived');
  const key = await crypto.subtle.importKey('raw', AUTH_KEY, {name:'HMAC', hash:'SHA-256'}, false, ['sign']);
  const sig = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(message));
  return toBase64Url(sig);
}

function setupConnection(connection) {
  conn = connection;
  chatBox.style.display = "block";
  updateStatus('Connected to ' + connection.peer, 'connected');

  let isAuthenticated = false;
  let seenRemoteAuthToken = null;

  connection.on('open', async function() {
    if (AUTH_KEY && LOCAL_AUTH_TOKEN) {
      const msg = {
        type: 'auth-init',
        token: LOCAL_AUTH_TOKEN
      };
      try { connection.send(JSON.stringify(msg)); }
      catch(e){ console.warn('send auth-init failed', e); }
    }
  });

  connection.on('data', async function(raw) {
    try {
      let data = (typeof raw === 'string') ? tryParseJson(raw) : raw;

      if (data && data.type === 'auth-init') {
        if (AUTH_KEY) {
          seenRemoteAuthToken = data.token;
          const proof = await computeHMAC(data.token + '|' + LOCAL_AUTH_TOKEN);
          const msg = { type: 'auth-answer', token: LOCAL_AUTH_TOKEN, proof };
          connection.send(JSON.stringify(msg));
        } else {
          connection.send(JSON.stringify({ type: 'auth-request' }));
        }
        return;
      }

      if (data && data.type === 'auth-answer') {
        if (AUTH_KEY) {
          const expected = await computeHMAC(data.token + '|' + LOCAL_AUTH_TOKEN);
          if (expected === data.proof) {
            isAuthenticated = true;
            updateStatus('Authenticated with ' + connection.peer, 'connected');
          } else {
            console.warn('Auth mismatch â€” closing');
            connection.send(JSON.stringify({ type: 'auth-failed' }));
            connection.close();
          }
        }
        return;
      }

      if (data && data.type === 'auth-request') {
        alert('Remote peer requests passphrase auth. Please click "Generate Connect Code" and/or enter passphrase in the connect box before reconnecting.');
        return;
      }

      if (data && data.type === 'photo') {
        if (typeof data.data === 'string' && data.data.startsWith('data:image/')) {
          const approxBytes = Math.floor((data.data.length * 3) / 4);
          if (approxBytes > 5 * 1024 * 1024) {
            console.warn('Received image too large, dropping');
            return;
          }
          addPhotoMessage(data.data, 'peer-msg');
        } else {
          console.error('Invalid photo data received');
        }
        return;
      }

      if (typeof data === 'object' && data !== null && data.type) {
        console.warn('Unknown structured message:', data);
        return;
      }

      if (typeof data === 'string') {
        addMessage(data, 'peer-msg');
      }
    } catch (e) {
      if (typeof raw === 'string') addMessage(raw, 'peer-msg');
      else console.error('Invalid data type received:', e);
    }
  });

  connection.on('close', function() {
    updateStatus('Connection lost', 'error');
    endCall();
    conn = null;
  });
}

function tryParseJson(s) {
  try { return JSON.parse(s); } catch(e) { return null; }
}

async function startCall() {
  if (!conn) return alert('Connect to a peer first!');
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    localVideo.srcObject = localStream;
    call = peer.call(conn.peer, localStream);
    call.on('stream', remoteStream => {
      remoteVideo.srcObject = remoteStream;
      showVideoSection();
    });
    call.on('close', () => endCall());
  } catch (err) {
    console.error('Failed to start call:', err);
    alert('Camera/microphone access denied or not available');
  }
}

function endCall() {
  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
  }
  if (call) { call.close(); call = null; }
  localVideo.srcObject = null;
  remoteVideo.srcObject = null;
  videoSection.classList.add('hidden');
  isAudioMuted = false;
  isVideoOff = false;
  updateMuteButton();
  updateVideoButton();
}

function toggleMute() {
  if (!localStream) return;
  const audioTracks = localStream.getAudioTracks();
  if (audioTracks.length > 0) {
    audioTracks[0].enabled = !audioTracks[0].enabled;
    isAudioMuted = !audioTracks[0].enabled;
    updateMuteButton();
  }
}
function toggleVideo() {
  if (!localStream) return;
  const videoTracks = localStream.getVideoTracks();
  if (videoTracks.length > 0) {
    videoTracks[0].enabled = !videoTracks[0].enabled;
    isVideoOff = !videoTracks[0].enabled;
    updateVideoButton();
  }
}
function updateMuteButton(){ const btn=document.getElementById('mute-btn'); btn.textContent = isAudioMuted ? 'ðŸ”‡' : 'ðŸŽ¤'; }
function updateVideoButton(){ const btn=document.getElementById('video-btn'); btn.textContent = isVideoOff ? 'ðŸ“¹âŒ' : 'ðŸ“¹'; }
function showVideoSection(){ videoSection.classList.remove('hidden'); }

function sendPhoto() {
  const fileInput = document.getElementById('photo-input');
  const file = fileInput.files[0];
  if (!file) return;
  if (!conn) return alert('Connect to a peer first!');
  if (!file.type.startsWith('image/')) {
    alert('Please select an image file');
    fileInput.value = '';
    return;
  }
  const maxSize = 5 * 1024 * 1024;
  if (file.size > maxSize) {
    alert('Image is too large. Please select an image smaller than 5MB');
    fileInput.value = '';
    return;
  }
  const reader = new FileReader();
  reader.onload = function(e) {
    const photoData = { type: 'photo', data: e.target.result };
    try { conn.send(JSON.stringify(photoData)); } catch(e) { console.warn('send failed', e); conn.send(photoData); }
    addPhotoMessage(e.target.result, 'my-msg');
  };
  reader.readAsDataURL(file);
  fileInput.value = '';
}

function addPhotoMessage(photoDataUrl, className) {
  const div = document.createElement('div');
  div.className = 'message ' + className;
  const img = document.createElement('img');
  img.src = photoDataUrl;
  img.className = 'message-img';
  img.alt = 'Shared photo';
  img.onclick = () => {
    const link = document.createElement('a');
    link.href = photoDataUrl;
    link.download = 'shared-photo.jpg';
    link.target = '_blank';
    link.click();
  };
  div.appendChild(img);
  msgDisplay.appendChild(div);
  msgDisplay.scrollTop = msgDisplay.scrollHeight;
}

function sendMessage() {
  let input = document.getElementById('msg-input');
  let msg = input.value.trim();
  if (!msg || !conn) return;
  const payload = JSON.stringify({ type: 'text', text: msg });
  try { conn.send(payload); } catch(e) { conn.send(msg); }
  addMessage(msg, 'my-msg');
  input.value = "";
}

function addMessage(msg, className) {
  let div = document.createElement('div');
  div.className = 'message ' + className;
  div.textContent = msg;
  msgDisplay.appendChild(div);
  msgDisplay.scrollTop = msgDisplay.scrollHeight;
}

function updateStatus(message, type) {
  statusDisplay.textContent = message;
  statusDisplay.className = 'status ' + type;
}

function handleEnter(e) {
  if (e.key === 'Enter') sendMessage();
}

</script>

</body>
</html>
'''

# write file
path = '/mnt/data/chat.html'
with open(path, 'w', encoding='utf-8') as f:
    f.write(html_content)

path

